import fs from "fs";
import path from "path";
import { ComicMeta, ComicListItem } from "./types";

const DATA_DIR = path.join(process.cwd(), "data", "comics");

/**
 * Ensure data directory exists
 */
export function ensureDataDir(): void {
  if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
  }
}

/**
 * Get path to comic directory
 */
export function getComicPath(id: string): string {
  return path.join(DATA_DIR, id);
}

/**
 * Save comic metadata
 */
export async function saveComicMeta(id: string, meta: ComicMeta): Promise<void> {
  ensureDataDir();
  const comicDir = getComicPath(id);
  
  if (!fs.existsSync(comicDir)) {
    fs.mkdirSync(comicDir, { recursive: true });
  }

  const pagesDir = path.join(comicDir, "pages");
  if (!fs.existsSync(pagesDir)) {
    fs.mkdirSync(pagesDir, { recursive: true });
  }

  const metaPath = path.join(comicDir, "meta.json");
  fs.writeFileSync(metaPath, JSON.stringify(meta, null, 2));
}

/**
 * Save full story structure generated by LLM
 */
export async function saveStoryStructure(id: string, story: any): Promise<void> {
  ensureDataDir();
  const comicDir = getComicPath(id);
  
  if (!fs.existsSync(comicDir)) {
    fs.mkdirSync(comicDir, { recursive: true });
  }

  const storyPath = path.join(comicDir, "story.json");
  fs.writeFileSync(storyPath, JSON.stringify(story, null, 2));
}

/**
 * Save comic page image
 */
export async function saveComicPage(
  id: string,
  pageNumber: number,
  imageBuffer: Buffer
): Promise<void> {
  const pagesDir = path.join(getComicPath(id), "pages");
  
  // Ensure pages directory exists
  if (!fs.existsSync(pagesDir)) {
    fs.mkdirSync(pagesDir, { recursive: true });
  }
  
  const pagePath = path.join(pagesDir, `page${pageNumber}.png`);
  fs.writeFileSync(pagePath, imageBuffer);
}

/**
 * Save comic PDF
 */
export async function saveComicPDF(id: string, pdfBuffer: Buffer): Promise<void> {
  const pdfPath = path.join(getComicPath(id), "comic.pdf");
  fs.writeFileSync(pdfPath, pdfBuffer);
}

/**
 * Get comic metadata
 */
export async function getComicMeta(id: string): Promise<ComicMeta | null> {
  const metaPath = path.join(getComicPath(id), "meta.json");
  
  if (!fs.existsSync(metaPath)) {
    return null;
  }

  const content = fs.readFileSync(metaPath, "utf-8");
  return JSON.parse(content);
}

/**
 * Get comic page
 */
export async function getComicPage(id: string, pageNumber: number): Promise<Buffer | null> {
  const pagePath = path.join(getComicPath(id), "pages", `page${pageNumber}.png`);
  
  if (!fs.existsSync(pagePath)) {
    return null;
  }

  return fs.readFileSync(pagePath);
}

/**
 * Get comic PDF
 */
export async function getComicPDF(id: string): Promise<Buffer | null> {
  const pdfPath = path.join(getComicPath(id), "comic.pdf");
  
  if (!fs.existsSync(pdfPath)) {
    return null;
  }

  return fs.readFileSync(pdfPath);
}

/**
 * List all comics
 */
export async function listAllComics(): Promise<ComicListItem[]> {
  ensureDataDir();

  if (!fs.existsSync(DATA_DIR)) {
    return [];
  }

  const entries = fs.readdirSync(DATA_DIR);
  const comics: ComicListItem[] = [];

  for (const entry of entries) {
    const comicPath = path.join(DATA_DIR, entry);
    const metaPath = path.join(comicPath, "meta.json");

    if (fs.existsSync(metaPath)) {
      try {
        const meta: ComicMeta = JSON.parse(fs.readFileSync(metaPath, "utf-8"));
        
        // Get first page as preview
        const firstPagePath = path.join(comicPath, "pages", "page1.png");
        let preview = "";
        
        if (fs.existsSync(firstPagePath)) {
          const imageBuffer = fs.readFileSync(firstPagePath);
          preview = `data:image/png;base64,${imageBuffer.toString("base64")}`;
        }

        comics.push({
          id: meta.id,
          preview,
          pitch: meta.pitch,
          style: meta.style,
          timestamp: meta.timestamp,
        });
      } catch (error) {
        console.error(`Error reading comic ${entry}:`, error);
      }
    }
  }

  // Sort by timestamp (newest first)
  comics.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

  return comics;
}

